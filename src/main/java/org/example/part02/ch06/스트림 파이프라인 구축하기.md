# 스트림 파이프라인 구축하기

---

### map / filter / reduce
- map : 데이터 변환
- filter : 데이터 선택
- reduce : 결과 도출

위의 패턴은 `요소의 연속을 하나의 단위로 취급`한다. <br>
중간 연산은 map / filter 단계를 나타내고, 최종 연산은 reduce 단계를 나타낸다.

**예제에 사용할 Shape 클래스**
```java
public record Shape(int corners) implements Comparable<Shape> {

    public boolean hasCorners() {
        return corners() > 0;
    }

    public List<Shape> twice() {
        return List.of(this, this);
    }

    @Override
    public int compareTo(Shape o) {
        return Integer.compare(corners(), o.corners());
    }

    public static Shape circle() {
        return new Shape(0);
    }

    public static Shape triangle() {
        return new Shape(3);
    }

    public static Shape square() {
        return new Shape(4);
    }
}

```

### 요소 선택
- 특정 조건에 따라 요소를 선택한다.
- 이는 Predicate를 이요한 필터링 혹은 요소의 개수를 기반으로 선택함으로써 이루어진다.
```java
List<Shape> shapeList = Arrays.asList(Shape.square(), Shape.triangle(), Shape.triangle(), Shape.circle(), Shape.square(), Shape.circle());

// 스트림 생성
Stream<Shape> stream = shapeList.stream();

// filter -> 결과가 true인 해당 요소는 선택된다.
stream.filter(Shape::hasCorners).forEach(System.out::println);

// TODO dropWhile -> true가 될 때까지 통과하는 모든 요소를 폐기한다.
stream.dropWhile(Shape::hasCorners).forEach(System.out::println);

//takeWhile -> false가 될 때까지 요소를 선택한다.
stream.takeWhile(Shape::hasCorners).forEach(System.out::println);

// limit (long maxSize) -> 요소의 최대 개수를 maxSize로 제한한다.
stream.limt(2L).forEach(System.out::println);

// skip (long n) -> 앞에서부터 n개의 요소를 건너뛰고, 나머지 요소들을 다음 스트림 연산을 전달
stream.skip(2L).forEach(System.out::println);
        
// distinct - > 중복되지 않은 요소만 반환. 연산을 비교하기 위해 모든 요소를 버퍼에 저장
stream.distinct().forEach(System.out::println);

// sorted -> Comparable이 구현되어 있다면 자연스럽게 정렬된다. 안된 경우 ClasCastException이 발생한다.
stream.sorted().forEach(System.out::println);
```

### 요소 매핑
```java
List<Shape> shapeList = Arrays.asList(Shape.square(), Shape.triangle(), Shape.triangle(), Shape.circle(), Shape.square(), Shape.circle());

Stream<Shape> stream = shapeList.stream();

// map -> 함수가 요소에 적용되고 새로운 요소가 스트림으로 반환된다.
// map 함수의 반환 타입(Integer)으로 새로운 요소가 반환된다.
// Stream<Integer> integerStream = stream.map(Shape::corners);
stream.map(Shape::corners).forEach(System.out::println);

// flatMap -> 컬렉션, Optional 같은 컨테이너 형태의 요소를 펼쳐서 새로운 다중 요소로 포함하는 새로운 스트림을 반환
// Stream<List<Shape>> listStream = stream.map(Shape::twice);
// Stream<Shape> shapeStream = listStream.flatMap(List::stream);
stream.map(Shape::twice).flatMap(List::stream).forEach(System.out::println);
```

### Peek
- 스트림은 많은 기능을 하나의 호출로 묶어 간결하게 코드를 작성할 수 있지만 디버깅의 단점이 있다.
- peek 연산은 주로 디버깅을 지원하지 위해 설계되었는데 스트림의 요소에 개입하지 않고 스트림을 들여다볼 수 있다.
```java
Stream.of(Shape.square(), Shape.triangle(), Shape.circle())
        .map(Shape::twice)
        .flatMap(List::stream)
        .peek(shape -> System.out.println("current: " + shape))
        .filter(shape -> shape.corners() < 4)
        .collect(Collectors.toList());
```

### 요소 축소
- 누적 연산자를 반복적으로 적용하여 스트림의 요소들을 하나의 결괏값으로 만든다.
- 누적자는 중간 자료 구조를 필요로 하지 않으며 항상 새로운 값을 반환 한다.

**스트림의 reduce**

1. BinaryOperator만 사용하는 reduce
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);

// 스트림 요소가 없는 경우 Optional을 반환한다.
Optional<Integer> result = list.stream().reduce((a, b) -> a + b);
result.ifPresent(System.out::println); // 15
```
2. Identity와 BinaryOperator를 사용한 reduce
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
// 초기값이 0으로 설정되어 결과는 항상 Integer로 반환된다.
Integer result = list.stream().reduce(0, (a, b) -> a + b);
System.out.println(result); // 15
```

3. Identity, BinaryOperator, combiner
- map과 reduce를 결합한 변형.
- 스트림에는 T 타입의 요소가 포함되어 있지만 원하는 결과가 U 타입인 경우 사용할 수 있다. 
```java
Integer result = list.stream().reduce(0, (a, b) -> a + b, Integer::sum);
System.out.println(result); // 15

List<String> list2 = Arrays.asList("apple", "banana", "cherry");
int result2 = list2.stream()
        .mapToInt(String::length)
        .reduce(0, (a, b) -> a + b);
System.out.println(result2); // 17
```