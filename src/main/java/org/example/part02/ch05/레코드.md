# 레코드

---

- 간단한 구문으로도 다양한 형태의 `데이터를 집계`할 수 있는 기능을 가진다.
  - 다양한 소스로부터 데이터를 수집하고 의도한 목적에 부합하도록 표현하는 과정.
  - 잘 알려진 데이터 집계 유형으론 `튜플`이 있다.

### 튜플
- 여러 값을 하나의 묶음으로 저장할 수 있는 자료형

**1. 구조적 튜플**
- 데이터의 순서와 개수를 기준으로 정의
- 데이터의 타입과 순서에만 의존하므로 인덱스를 통해서만 접근이 가능하다.

**2. 명목상 튜플**
- 데이터의 의미와 타입을 기반으로 정의
- 각 요소는 명명된 필드를 가지고 있으며, 인덱스를 사용하지 않고 타입명을 사용한다.

레코드는 명목상 튜플과 같이 이름으로 데이터 컴포넌트에 접근하여 데이터 집계 타입을 정의하는 방법이다.

## 레코드 특징

### 컴포넌트 접근자
- 모든 레코드 컴포넌트는 private 필드로 저장된다.
- 레코드 내부에서는 필드에 직접 접근이 가능하지만, 외부에서는 public 접근자 메서드를 통해서만 접근 가능하다.

### 표준, 간결, 사용자 정의 생성자
- 각 컴포넌트에 따라 자동으로 생성되는 생성자를 표준 생성자라 한다.
- 기본 생성자에서 유효성 검사나 필요에 따라 데이터를 조정하기 위해 재정의될 수 있다
  - 유효성 검사를 위한 생성자 시그니처 재선언, 컴포넌트 할당 등 추가로 많은 코드를 작성해야 한다.
```java
public record User(String name, boolean active, LocalDateTime lastLogin) {

    public User(String name, boolean active, LocalDateTime lastLogin) {
      Objects.requireNonNull(name);
      Objects.requireNonNull(lastLogin);
  
      this.name = name;
      this.active =active;
      this.lastLogin = lastLogin;
    }
}
```
- 이런 경우 간결한 생성자를 만들어 사용할 수 있는데, 인수가 없는 생성자와 명확하게 구분할 수 있다.
```java
public record User(String name, boolean active, LocalDateTime lastLogin) {
    public User {
        Objects.requireNonNull(name);
        Objects.requireNonNull(lastLogin);
    }
}
```

### 객체 식별
- 레코드는 데이터 동등성을 기반으로 하는 hashCode와 equals 메서드의 표준 구현을 제공한다.
- 레코드 타입의 두 인스턴스는 컴포넌트의 데이터가 동일하면 동일하다고 간주된다.
```java
RecordPerson recordPerson = new RecordPerson("성현", 28);
RecordPerson recordPerson2 = new RecordPerson("성현", 28);

recordPerson.equals(recordPerson2) // true
```

### 어노테이션
- 레코드 컴포넌트에 어노테이션을 사용할 경우, ElementType.PARAMETER와 관련된 어노테이션만 가능하다.
- 파라미터뿐 아니라, 필드, 접근자로 인한 추가적인 고려사항이 필요하다.
```java
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.TYPE_USE})
//...
public @interface NonNull {
}
```

### 리플렉션
- getRecordComponents 메서드를 사용해 레코드 클래스의 컴포넌트 정보를 얻을 수 있다.
```java
public record Person(String name, int age) {}

public static void main(String[] args) {
    RecordComponent[] components = Person.class.getRecordComponents();
  
    for (RecordComponent component : components) {
        System.out.println(component.getName());
        System.out.println(component.getType()); 
        System.out.println();
    }
    
    // name     age
    // String   int
}
```

### 상속
- 레코드는 내부적으로 java.lang.Record를 상속한 final 타입이다.
- 상속할 수는 없지만 인터페이스는 구현 가능하다.
- 인터페이스를 사용하여 레코드 템플릿을 정의하고 default 메서드를 통해 공통 기능을 공유할 수 있다.
```java

```

### 빌더 패턴
```java
public static void main(String[] args) {
        User user = new User.UserBuilder().id(1L).username("성현").build();

        System.out.println(user.id());
        System.out.println(user.username());
    }

public record User(Long id, String username) {

    public static final class UserBuilder {
        private Long id;
        private String username;

        public UserBuilder id(Long id) {
            this.id = id;
            return this;
        }

        public UserBuilder username(String username) {
            this.username = username;
            return this;
        }
        
        public User build() {
            return new User(id, username);
        }
    }
}
```