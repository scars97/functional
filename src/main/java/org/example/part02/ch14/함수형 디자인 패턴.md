# 함수형 디자인 패턴

---

## 디자인 패턴

### 생성 패턴
객체의 생성 방식을 결정하는 패턴

### 구조 패턴
- 객체를 조합해 더 큰 구조나 강화된 객체를 만드는 패턴

### 행동 패턴
- 객체 간의 책임과 통신을 다루는 패턴

## 자주 사용되는 디자인 패턴

### 팩토리 패턴
객체를 생성하는 방법의 세부 사항을 드러내지 않고 객체의 인스턴스를 생성한다.

**객체 지향 접근 방식**
- 식별 객체
- 객체를 생성하는 Factory
```java
// 공통 인터페이스
public interface Shape {
    int corners();
    Color color();
    ShapeType type();
}

// 도형의 타입과 색상을 식별하는 열거형
public enum ShapeType {
    CIRCLE, TRIANGLE, SQUARE
}
public enum Color {
    RED, BLUE, GREEN
}

// 식별 객체
public record Circle(Color color) implements Shape {
    @Override
    public int corners() { return 0; }
    @Override
    public ShapeType type() { return ShapeType.CIRCLE; }
}

// 타입과 색상을 기반으로 도형을 생성하는 Factory
public class ShapeFactory {
    public static Shape newShape(ShapeType type, Color color) {
        Objects.requireNonNull(color);

        return switch (type) {
            case CIRCLE -> new Circle(color);
            case SQUARE -> new Square(color);
            case TRIANGLE -> new Triangle(color);
            default -> throw new IllegalArgumentException("Unknown type: " + type);
        };
    }
}
public class FactoryEx {
    public static void main(String[] args) {
        Shape circle = ShapeFactory.newShape(ShapeType.CIRCLE, Color.GREEN);
        Shape square = ShapeFactory.newShape(ShapeType.SQUARE, Color.BLUE);
        Shape triangle = ShapeFactory.newShape(ShapeType.TRIANGLE, Color.RED);
    }
}
```
- 만약 새로운 ShapeType이 추가된다면 구체 타입 클래스(ex PENTAGON) 추가 및 ShapeType와 Factory의 수정이 필요하다.
- 그렇지 않으면 구체적인 구현 타입이 존재하더라도 switch 문에 의해 IllegalArgumentException 이 발생할 수 있다.

**함수적 접근 방식**
- 결국 ShapeType 에 있는 타입들로 객체가 생성되기 때문에 Factory 클래스의 기능을 ShapeType에 구현할 수 있다.
```java
// ShapeType - factory 함수 구현
public enum ShapeType {
    CIRCLE(Circle::new),
    TRIANGLE(Triangle::new),
    SQUARE(Square::new);

    public final Function<Color, Shape> factory;

    ShapeType(Function<Color, Shape> factory) {
        this.factory = factory;
    }

    // 인스턴스 생성 메서드
    public Shape newInstance(Color color) {
        Objects.requireNonNull(color);
        Function<Shape, Shape> shapePrint =
                shape -> {
                    System.out.println("type: " + shape.type() + "\ncolor: " + shape.color() + "\ncorners: " + shape.corners());
                    return shape;
                };

        return this.factory.andThen(shapePrint).apply(color);
    }
}
```
- 추가하고자 하는 도형 타입이 있다면 추가할 상수만 선언하면 되는데,
- 상수 선언 시 컴파일러가 팩토리 메서드 제공을 강제하기 때문에 추가될 항목에 대해 누락될 가능성을 없애준다.
```java
Shape circle = ShapeType.CIRCLE.newInstance(Color.RED);
Shape triangle = ShapeType.TRIANGLE.newInstance(Color.GREEN);
Shape square = ShapeType.SQUAD.newInstance(Color.BLUE);
```

### 데코레이션 패턴
객체의 동작을 런타임에서 변경할 수 있도록 하는 구조 패턴

**객체 지향 접근 방식**
- **Coffee**: 블랙 커피
- **CoffeeMaker**: 커피를 제조하는 공통의 작업을 정의 
- **BlackCoffeeMaker**: 특정 커피 즉, 블랙 커피를 제조하는 구제척 작업을 정의
- **Decorator**: 제조 중인 커피에 재료를 추가할 수 있는 기능 정의
- **AddMilkDecorator**: 제조 중인 커피에 스팀 우유를 추가하는 기능 정의(MilkCarton(우유갑)의 pourInfo(붓는 행위)를 통해 커피에 우유 추가)
- **AddSugarDecorator**: 제조 중인 커피에 설탕 추가 기능 정의

**커피 메뉴**
```java
public enum Coffee {
    BLACK_COFFEE
}
```

**커피 제조 기능 정의**
```java
public interface CoffeeMaker {
    List<String> getIngredients();
    Coffee prepare();
}

public class BlackCoffeeMaker implements CoffeeMaker {
    @Override
    public List<String> getIngredients() { return List.of("Robusta Beans", "Water");}
    @Override
    public Coffee prepare() { return Coffee.BLACK_COFFEE; }
}
```

**재료 추가 기능 정의**
```java
public class Decorator implements CoffeeMaker {
    private final CoffeeMaker target;

    public Decorator(CoffeeMaker target) { this.target = target;}

    @Override
    public List<String> getIngredients() { return this.target.getIngredients(); }
    @Override
    public Coffee prepare() { return this.target.prepare(); }
}

public class AddMilkDecorator extends Decorator {
    private final MilkCarton milkCarton;

    public AddMilkDecorator(CoffeeMaker target, MilkCarton milkCarton) {
        super(target);
        this.milkCarton = milkCarton;
    }

    @Override
    public List<String> getIngredients() {
        List<String> newIngredients = new ArrayList<>(super.getIngredients());
        newIngredients.add("Milk");
        return newIngredients;
    }

    @Override
    public Coffee prepare() {
        Coffee coffee = super.prepare();
        return this.milkCarton.pourInfo(coffee);
    }
}
```
```java
public class Main {

    public static void main(String[] args) {
        CoffeeMaker coffeeMaker = new BlackCoffeeMaker();
        System.out.println(coffeeMaker.getIngredients());
        
        CoffeeMaker decoratedCoffeeMaker = new AddMilkDecorator(coffeeMaker, new MilkCarton());
        System.out.println(decoratedCoffeeMaker.getIngredients());

        CoffeeMaker lastDecoratedCoffeeMaker = new AddSugarDecorator(decoratedCoffeeMaker);
        System.out.println(lastDecoratedCoffeeMaker.getIngredients());
        
        // [Robusta Beans, Water]
        // [Robusta Beans, Water, Milk]
        // [Robusta Beans, Water, Milk, Sugar]
    }
}
```

**함수적 접근 방식**
- 제조할 커피를 먼저 생성하고, 데코레이터를 생성하여 제조 중인 커피를 장식한다.
- BlackCoffeeMaker, Decorator 모두 CoffeeMaker를 반환한다면 함수 합성을 사용해 하나의 동작으로 묶어보는 건 어떨까
```java
public class Barista {

    // 단일 함수
    public static CoffeeMaker decorate(CoffeeMaker coffeeMaker,
                                       Function<CoffeeMaker, CoffeeMaker> decorator) {
        return decorator.apply(coffeeMaker);
    }
}
```
```java
// Add Milk
CoffeeMaker decoratedCoffeeMaker =
        Barista.decorate(new BlackCoffeeMaker(),
                        coffeeMaker -> new AddMilkDecorator(coffeeMaker, new MilkCarton()));
// Add Sugar
CoffeeMaker finalCoffeeMaker = Barista.decorate(decoratedCoffeeMaker, AddSugarDecorator::new);
```
- 제조하고자 하는 커피와 추가할 장식을 하나의 동작으로 묶었다.
- 하지만 단일 함수로 작성하여 장식을 추가할 때마다 CoffeeMaker를 새로 생성한다.
- 한번에 여러 장식을 추가하고자 한다면 가변 함수를 사용할 수 있다.
```java
public class Barista {

    // 단일 함수
    // ...

    // 가변 함수
    @SafeVarargs
    public static CoffeeMaker decorate(CoffeeMaker coffeeMaker,
                                       Function<CoffeeMaker, CoffeeMaker>... decorators) {
        Function<CoffeeMaker, CoffeeMaker> reducedDecorations =
                Arrays.stream(decorators)
                        .reduce(Function.identity(),
                                Function::andThen);
        return reducedDecorations.apply(coffeeMaker);
    }
}
```
- 데코레이션들은 Stream<Function<CoffeeMaker, CoffeeMaker>>을 사용해 배열로부터 스트림을 생성하고, 각각을 결합하여 모든 요소를 하나의 Function<CoffeeMaker, CoffeeMaker>로 축소한다.
- 마지막으로 축소된 단일 데코레이션은 CoffeeMaker와 결합된다.
```java
CoffeeMaker maker = Barista.decorate(new BlackCoffeeMaker(),
                                    coffeeMaker -> new AddMilkDecorator(coffeeMaker, new MilkCarton()),
                                    AddSugarDecorator::new);
```
- 가변 인자로 받을 수 있게 되어 코드가 단일 호출로 간소화되었지만 데코레이션의 구체적인 구현들을 한 메서드 안에 작성해야 한다.
- 정적 팩토리 메서드를 사용하여 데코레이션을 그룹화하면 데코레이터의 구체적인 구현을 공개할 필요가 없어지며, 추가 장식에만 집중할 수 있다.
```java
public final class Decorations {

    // Add Milk
    public static Function<CoffeeMaker, CoffeeMaker> addMilk(MilkCarton milkCarton) {
        return coffeeMaker -> new AddMilkDecorator(coffeeMaker, milkCarton);
    }

    // Add Sugar
    public static Function<CoffeeMaker, CoffeeMaker> addSugar() {
        return AddSugarDecorator::new;
    }
}
```
```java
CoffeeMaker maker = Barista.decorate(new BlackCoffeeMaker(),
                                    Decorations.addMilk(new MilkCarton()),
                                    Decorations.addSugar());
```

> @SafeVarargs
> - 가변 인자와 제네릭 사용 시 타입 안정성 문제를 경고한다.
> - 자바에서 가변 인자 메서드는 내부적으로 배열을 사용하는데 제네릭 타입의 배열은 타입 안정성을 완전히 보장하지 못한다. (공변, 불공변 차이)
>   - AddMilkDecorator는 Decorator의 하위 타입이고, Decorator는 결국 Object의 하위 타입이 때문에 가변인자 Decorator(Decorator...)는 타입 안전을 보장받을 수 있다.
>   - 제네릭의 경우 타입 정보는 컴파일 타임에만 존재하며, 런타임에는 타입 소거로 인해 사라진다.
> - 가변 인자와 제네릭스의 조합으로 인해 발생할 수 있는 문제를 방지하려면, 해당 메서드가 타입 안전함을 보장할 수 있을 때 @SafeVarargs를 사용할 수 있다.