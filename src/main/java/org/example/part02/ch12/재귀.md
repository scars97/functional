# 재귀

---

### 개념
- 함수가 자기 자신을 호출하는 프로그래밍 기법
- 문제를 작은 하위 문제들로 나누어 해결하는데 유용하며, `반복적으로 동일한 작업을 수행해야 하는 경우` 사용된다.

### 재귀의 기본 구조
- **기본 사례(Base Case)**: 재귀 호출을 멈추는 조건으로, 기본 사례가 없으면 재귀 호출이 무한 반복될 수 있다.
- **재귀 사례(Recursive Case)**: 함수가 자기 자신을 호출하는 부분이다. 이 부분에서 문제를 더 작은 부분으로 나눌 수 있다.
```java
public class FactorialEx {
    public static void main(String[] args) {
        int number = 5;
        int result = factorial(number);
        System.out.println("Factorial of " + number + " is " + result);
        // Factorial of 5 is 120
    }

    static int factorial(int n) {
        if (n == 0) { // 기본 사례
            return 1;
        } else { // 재귀 사례
            return n * factorial(n - 1); // n! = n * (n-1) * (n-2) * ... * 1
        }
    }
}
```
- 재귀를 사용하여 복잡한 문제를 더 작은 문제로 분할하여 해결할 수 있다.
- 하지만 성능 문제, 메모리 사용에 단점이 있다.
  - 성능 문제: 재귀 호출은 함수 호출 스택을 사용하기 때문에, 깊은 재귀는 Stackoverflow를 초래할 수 있다.
  - 메모리 사용: 재귀 호출마다 새로운 스택 프레임을 생성하므로, 메모리 사용량이 증가할 수 있다.

### 재귀 최적화

**꼬리 재귀 최적화**
```java
public class FactorialTailEx {
    public static void main(String[] args) {
        int number = 5;
        int result = factorial(number);
        System.out.println("Factorial of " + number + " is " + result);
        // Factorial of 5 is 120
    }

    static int factorialTail(int n, int accumulator) {
        if (n == 0) {
            return accumulator;
        } else {
            return factorialTail(n - 1, n * accumulator);
        }
    }
}
```
- 기존 factorial 메서드에서는 가장 깊은 호출이 완료된 후에 반환값을 통해 각 호출의 결과를 계산한다.
- 이 과정에서 `모든 재귀 호출이 종료된 후 스택 프레임을 따라 올라가며 계산이 수행`된다.
- 반면, 꼬리 재귀에서는 가장 깊은 호출이 마지막 작업으로, 스택 프레임을 따라 올라가지 않고 계산된 accumulator가 반환된다.
- 가장 `마지막으로 호출된 스택 프레임을 재사용`함으로써, 메모리 사용을 최적화할 수 있다.
