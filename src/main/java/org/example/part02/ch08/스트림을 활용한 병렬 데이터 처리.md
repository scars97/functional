# 스트림을 활용한 병렬 데이터 처리

---

## 동시성 병렬성

**동시성**
- 여러 작업이 중복되는 시간 동안 한정된 리소스에 대한 경쟁을 하면서 실행되는 것을 의미
- 실제로 작업이 동시에 실행되지는 않지만 단일 CPU 코어에서는 작업 간 전환이 빨라 동시에 실행되는 것처럼 보인다.
- 동시성은 I/O 작업을 처리할 때 효율적인데, I/O 요청 후 응답까지의 대기 시간(CPU 대기 시간) 중에 다른 작업을 처리할 수 있기 때문이다.
- 하지만 여러 작업을 동시에 수행하므로 `경합 상태`, `데드락`, `기아` 등의 동기화 문제가 발생할 수 있다.

**병렬성**
- 중첩된 작업들을 관리하는 것이 아닌, 작업들이 `동시에 실행`되는 것에 중점을 둔다.
- 여러 개의 CPU 코어를 사용할 수 있는 경우 각각의 작업들은 서로 다른 코어에서 병렬로 실행될 수 있다.
- 병렬성은 CPU 바운드 작업에 적합하다. CPU 바운드 작업이란 주로 CPU의 계산 능력에 의해 작업 속도가 결정되는 작업을 말한다.
- 대규모 수학 계산, 빅데이터 처리와 같은 큰 작업을 여러 작은 부분으로 나누어 멀티 코어에서 동시에 처리할 수 있다. 이를 통해 작업의 처리 시간을 줄이고 성능 향상의 이점을 준다.

동시성은 한 번에 여러 작업을 처리하는 것을 의미하고, 병렬성은 한 번에 여러 작업을 실행하는 것을 의미한다.

동시성을 가진 구조로 설계하고, 그 구조를 병렬적인 실행방식으로 구현한다.

## 병렬 함수 파이프라인으로써의 스트림
- 스트림은 중간 스트림 연산인 parallel 을 사용하여 병렬 모드로 전환할 수 있다.
- parallel을 호출하여 실행 모드를 변경하면 파이프라인 내의 위치에 관계 없이 전체 스트림 파이프라인에 영향을 미친다.
- 최종 연산 전에 마지막으로 호출된 메서드가 전체 파이프라인의 실행 모드를 결정한다.
```java
List<Integer> parallelNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

List<Integer> result = parallelNumbers.stream()
        .filter(n -> n % 2 == 0)
        .map(n -> n * n)
        .parallel() // 병렬 모드 전환
        .collect(Collectors.toList());

System.out.println(result);
// [4, 16, 36, 64, 100]
```
- filter와 map 연산은 메인 스레드에서 수행된다.
- parallel 호출로 병렬모드로 전환되고 최종연산인 collect은 병렬 모드로 수행된다.

### 병렬 스트림
- 병렬 스트림은 재귀적 분해 개념을 사용. 
- spliterator로 분할하여 요소의 덩어리를 병렬 처리함으로써 데이터 소스를 `분할하고 정복`하는 것을 의미
  - 분할된 덩어리는 전용 스레드에 의해 처리되며 재귀적으로 더 분할될 수 있다.
- 분할되어 처리된다하여, 별도로 스레드를 만들거나 관리하는 등의 작업을 할 필요는 없다.
  - `스트림 API는 내부적으로 ForkJoinPool 을 활용`하여 스레드를 효과적으로 생성하고 관리하기 때문
> ForkJoinPool
- 작업 훔치기 방식으로 스레드를 실행.
- 한 작업 스레드가 자신에게 할당된 작업을 마친 후, 다른 스레드가 아직 처리하지 못한 작업을 훔쳐와서 실행한다.
- ForJoinPool 은 런타임에서 자체적으로 관리하며, 초기화가 지연되는 정적 스레드 풀이다.
- 모든 CPU 코어를 동시에 과도하게 사용하는 상황을 피한다.

![img.png](ForkJoinPool.png)

## 병렬 스트림 활용
- 단일 스레드에서의 작업 시간과 병렬 스트림을 사용하여 작업한 시간을 비교한 예제
```java
List<Integer> numbers = new ArrayList<>();
for (int i = 0; i < 1_000_000; i++) {
    numbers.add(i);
}

// 단일 스레드 처리 시간 측정
long startTime = System.nanoTime();
/*int[] singleThreadMultiple1 = numbers.stream()
        .mapToInt(n -> n * n)
        .toArray();*/
Object[] singleThreadMultiple2 = numbers.stream()
        .map(n -> n * n)
        .toArray();
long singleThreadTime = System.nanoTime() - startTime;

System.out.println("단일 스레드 처리 시간: " + singleThreadTime / 1_000_000.0 + " ms");

// 병렬 스트림 처리 시간 측정
startTime = System.nanoTime();
/*int[] multiThreadMultiple1 = numbers.parallelStream()
        .mapToInt(n -> n * n)
        .toArray();*/
Object[] multiThreadMultiple2 = numbers.parallelStream()
        .map(n -> n * n)
        .toArray();
long parallelStreamTime = System.nanoTime() - startTime;

System.out.println("병렬 스트림 처리 시간: " + parallelStreamTime / 1_000_000.0 + " ms");

if (singleThreadTime < parallelStreamTime) {
    System.out.println("단일 승");
} else {
    System.out.println("멀티 승");
}

// 기본 타입 배열 -> 단일: 11.7893 ms  <  병렬: 59.07 ms
// 객체 타입 배열 -> 단일: 46.7091 ms  >  병렬: 32.0836 ms
```
- mapToInt를 사용하여 기본 타입의 배열로 반환하는 스트림이라면 단일 스레드가 더 빠르다.
- map을 사용하여 Object 타입의 배열로 반환한 스트림인 경우는 멀티 스레드가 더 빠르다.
  - 단일 스레드에서 객체타입으로 반환하는 중에 오토박싱 오버헤드가 영향을 준 것 같다.