# 람다 활용

---

## 람다 생성
새 인스턴스를 생성하려면 변수의 타입이 정의되어야 한다.
```java
Predicate<String> isNull = value -> value == null;
```
인수에 타입을 명시적으로 사용하는 경우에도 함수형 인터페이스 타입이 필요하다.
```java
// 컴파일 실패
var isNull = (String value) -> value == null;
```

**타입 호환성**
- 두 람다가 동일한 SAM 시그니처를 공유한다해도 타입 호환성 문제는 발생한다.
- LikePredicate<java.lang.String> cannot be converted to java.util.function.Predicate<java.lang.String>
```java
public static void main(String[] args) {
    LikePredicate<String> isNull = value -> value == null;

    Predicate<String> wontCompile = isNull;
}

interface LikePredicate<T> {
    boolean test(T value);
}
```
메서드 인수와 리턴 타입으로써 생성된 람다는 타입 호환성 문제가 발생하지 않는다.
```java
Predicate<Integer> isGreaterThan(int value) {
    return compareValue -> compareValue > value;
}
```
메서드 시그니처에서 직접 람다의 타입을 추론하므로 람다로 얻고자 하는 결과에 집중할 수 있다.

## 람다 호출

**언어별 람다 호출 차이**
```js
let helloWorldJs = name => "hello, " + name + "!";
helloWorldJs("성현");
```
```java
Function<Integer, String> helloWorldJava = name -> "hello, " + name + "!";
helloWorldJava.apply("성현");
```
다른 언어처럼 간결하지 않을 수 있지만 자바의 `하위 호환성`이 지속된다는 이점이 있다.

>**하위 호환성**<br>
>새로운 버전의 자바가 이전 버전의 코드와 호환되는 정도를 의미<br>
>코드의 안전성과 신뢰성을 유지한다.